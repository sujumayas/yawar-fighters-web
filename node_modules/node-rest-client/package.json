{
  "_args": [
    [
      {
        "raw": "node-rest-client@^1.4.1",
        "scope": null,
        "escapedName": "node-rest-client",
        "name": "node-rest-client",
        "rawSpec": "^1.4.1",
        "spec": ">=1.4.1 <2.0.0",
        "type": "range"
      },
      "/home/diego/Code/yawarfighters/node_modules/rfg-api"
    ]
  ],
  "_from": "node-rest-client@>=1.4.1 <2.0.0",
  "_id": "node-rest-client@1.8.0",
  "_inCache": true,
  "_location": "/node-rest-client",
  "_npmUser": {
    "name": "acero",
    "email": "acero@fake.com"
  },
  "_npmVersion": "1.4.3",
  "_phantomChildren": {},
  "_requested": {
    "raw": "node-rest-client@^1.4.1",
    "scope": null,
    "escapedName": "node-rest-client",
    "name": "node-rest-client",
    "rawSpec": "^1.4.1",
    "spec": ">=1.4.1 <2.0.0",
    "type": "range"
  },
  "_requiredBy": [
    "/rfg-api"
  ],
  "_resolved": "https://registry.npmjs.org/node-rest-client/-/node-rest-client-1.8.0.tgz",
  "_shasum": "8d3c566b817e27394cb7273783a41caefe3e5955",
  "_shrinkwrap": null,
  "_spec": "node-rest-client@^1.4.1",
  "_where": "/home/diego/Code/yawarfighters/node_modules/rfg-api",
  "author": {
    "name": "Alejandro Alvarez Acero"
  },
  "bugs": {
    "url": "https://github.com/aacerox/node-rest-client/issues"
  },
  "dependencies": {
    "debug": "~2.2.0",
    "xml2js": ">=0.2.4"
  },
  "description": "node API REST client",
  "devDependencies": {
    "jasmine-node": ">=1.2.3"
  },
  "directories": {},
  "dist": {
    "shasum": "8d3c566b817e27394cb7273783a41caefe3e5955",
    "tarball": "https://registry.npmjs.org/node-rest-client/-/node-rest-client-1.8.0.tgz"
  },
  "engines": {
    "node": "*"
  },
  "homepage": "https://github.com/aacerox/node-rest-client#readme",
  "license": "MIT",
  "main": "./lib/node-rest-client",
  "maintainers": [
    {
      "name": "acero",
      "email": "acero@fake.com"
    }
  ],
  "name": "node-rest-client",
  "optionalDependencies": {},
  "readme": "# REST Client for Node.js\n\n**NOTE:** _Since version 0.8.0 node does not contain node-waf anymore. The node-zlib package which node-rest-client make use of, depends on node-waf.Fortunately since version 0.8.0 zlib is a core dependency of node, so since version 1.0 of node-rest-client the explicit dependency to \"zlib\" has been removed from package.json. therefore if you are using a version below 0.8.0 of node please use a versi√≥n below 1.0.0 of \"node-rest-client\". _ \n\nAllows connecting to any API REST and get results as js Object. The client has the following features:\n\n- Transparent HTTP/HTTPS connection to remote API sites.\n- Allows simple HTTP basic authentication.\n- Allows most common HTTP operations: GET, POST, PUT, DELETE, PATCH.\n- Direct or through proxy connection to remote API sites.\n- Register remote API operations as client own methods, simplifying reuse.\n- Automatic parsing of XML and JSON response documents as js objects.\n- Dynamic path and query parameters and request headers.\n- Improved Error handling mechanism (client or specific request)\n- Added support for compressed responses: gzip and deflate\n\n\n## Installation\n\n$ npm install node-rest-client\n\n## Usages\n\n### Simple HTTP GET\n\nClient has 2 ways to call a REST service: direct or using registered methods\n\n```javascript\nvar Client = require('node-rest-client').Client;\n\nvar client = new Client();\n\n// direct way\nclient.get(\"http://remote.site/rest/xml/method\", function (data, response) {\n\t// parsed response body as js object\n\tconsole.log(data);\n\t// raw response\n\tconsole.log(response);\n});\n\n// registering remote methods\nclient.registerMethod(\"jsonMethod\", \"http://remote.site/rest/json/method\", \"GET\");\n\nclient.methods.jsonMethod(function (data, response) {\n\t// parsed response body as js object\n\tconsole.log(data);\n\t// raw response\n\tconsole.log(response);\n});\n```\n\n### HTTP POST \n\nPOST, PUT or PATCH method invocation are configured like GET calls with the difference that you have to set \"Content-Type\" header in args passed to client method invocation:\n\n```javascript\n//Example POST method invocation\nvar Client = require('node-rest-client').Client;\n\nvar client = new Client();\n\n// set content-type header and data as json in args parameter\nvar args = {\n\tdata: { test: \"hello\" },\n\theaders: { \"Content-Type\": \"application/json\" }\n};\n\nclient.post(\"http://remote.site/rest/xml/method\", args, function (data, response) {\n\t// parsed response body as js object\n\tconsole.log(data);\n\t// raw response\n\tconsole.log(response);\n});\n\n// registering remote methods\nclient.registerMethod(\"postMethod\", \"http://remote.site/rest/json/method\", \"POST\");\n\nclient.methods.postMethod(args, function (data, response) {\n\t// parsed response body as js object\n\tconsole.log(data);\n\t// raw response\n\tconsole.log(response);\n});\n```\nIf no \"Content-Type\" header is set as client arg POST,PUT and PATCH methods will not work properly.\n\n\n### Passing args to registered methods\n\nYou can pass diferents args to registered methods, simplifying reuse: path replace parameters, query parameters, custom headers \n\n```javascript\nvar Client = require('node-rest-client').Client;\n\n// direct way\nvar client = new Client();\n\nvar args = {\n\tdata: { test: \"hello\" }, // data passed to REST method (only useful in POST, PUT or PATCH methods)\n\tpath: { \"id\": 120 }, // path substitution var\n\tparameters: { arg1: \"hello\", arg2: \"world\" }, // query parameter substitution vars\n\theaders: { \"test-header\": \"client-api\" } // request headers\n};\n\n\nclient.get(\"http://remote.site/rest/json/${id}/method?arg1=hello&arg2=world\", args,\n\tfunction (data, response) {\n\t\t// parsed response body as js object\n\t\tconsole.log(data);\n\t\t// raw response\n\t\tconsole.log(response);\n\t});\n\n\n// registering remote methods\nclient.registerMethod(\"jsonMethod\", \"http://remote.site/rest/json/${id}/method\", \"GET\");\n\n\n/* this would construct the following URL before invocation\n *\n * http://remote.site/rest/json/120/method?arg1=hello&arg2=world\n *\n */\nclient.methods.jsonMethod(args, function (data, response) {\n\t// parsed response body as js object\n\tconsole.log(data);\n\t// raw response\n\tconsole.log(response);\n});\n```\n\nYou can even use path placeholders in query string in direct connection:\n\n```javascript\nvar Client = require('node-rest-client').Client;\n\n// direct way\nvar client = new Client();\n\nvar args = {\n\tpath: { \"id\": 120, \"arg1\": \"hello\", \"arg2\": \"world\" },\n\tparameters: { arg1: \"hello\", arg2: \"world\" },\n\theaders: { \"test-header\": \"client-api\" }\n};\n\nclient.get(\"http://remote.site/rest/json/${id}/method?arg1=${arg1}&arg2=${arg2}\", args,\n\tfunction (data, response) {\n\t\t// parsed response body as js object\n\t\tconsole.log(data);\n\t\t// raw response\n\t\tconsole.log(response);\n\t});\n```\n\n\n\n###  HTTP POST and PUT methods\n\nTo send data to remote site using POST or PUT methods, just add a data attribute to args object:\n\n```javascript\nvar Client = require('node-rest-client').Client;\n\n// direct way\nvar client = new Client();\n\nvar args = {\n\tpath: { \"id\": 120 },\n\tparameters: { arg1: \"hello\", arg2: \"world\" },\n\theaders: { \"test-header\": \"client-api\" },\n\tdata: \"<xml><arg1>hello</arg1><arg2>world</arg2></xml>\"\n};\n\nclient.post(\"http://remote.site/rest/xml/${id}/method?arg1=hello&arg2=world\", args, function (data, response) {\n\t// parsed response body as js object\n\tconsole.log(data);\n\t// raw response\n\tconsole.log(response);\n});\n\n// registering remote methods\nclient.registerMethod(\"xmlMethod\", \"http://remote.site/rest/xml/${id}/method\", \"POST\");\n\n\nclient.methods.xmlMethod(args, function (data, response) {\n\t// parsed response body as js object\n\tconsole.log(data);\n\t// raw response\n\tconsole.log(response);\n});\n\n// posted data can be js object\nvar args_js = {\n\tpath: { \"id\": 120 },\n\tparameters: { arg1: \"hello\", arg2: \"world\" },\n\theaders: { \"test-header\": \"client-api\" },\n\tdata: { \"arg1\": \"hello\", \"arg2\": 123 }\n};\n\nclient.methods.xmlMethod(args_js, function (data, response) {\n\t// parsed response body as js object\n\tconsole.log(data);\n\t// raw response\n\tconsole.log(response);\n});\n```\n\n### Request/Response configuration\n\nIt's also possible to configure each request and response, passing its configuration as an\nadditional argument in method call.\n\n```javascript\nvar client = new Client();\n\n// request and response additional configuration\nvar args = {\n\tpath: { \"id\": 120 },\n\tparameters: { arg1: \"hello\", arg2: \"world\" },\n\theaders: { \"test-header\": \"client-api\" },\n\tdata: \"<xml><arg1>hello</arg1><arg2>world</arg2></xml>\",\n\trequestConfig: {\n\t\ttimeout: 1000, //request timeout in milliseconds\n\t\tnoDelay: true, //Enable/disable the Nagle algorithm\n\t\tkeepAlive: true, //Enable/disable keep-alive functionalityidle socket.\n\t\tkeepAliveDelay: 1000 //and optionally set the initial delay before the first keepalive probe is sent\n\t},\n\tresponseConfig: {\n\t\ttimeout: 1000 //response timeout\n\t}\n};\n\n\nclient.post(\"http://remote.site/rest/xml/${id}/method?arg1=hello&arg2=world\", args, function (data, response) {\n\t// parsed response body as js object\n\tconsole.log(data);\n\t// raw response\n\tconsole.log(response);\n});\n```\nIf you want to handle timeout events both in the request and in the response just add a new \"requestTimeout\"\nor \"responseTimeout\" event handler to clientRequest returned by method call.\n\n```javascript\nvar client = new Client();\n\n// request and response additional configuration\nvar args = {\n\tpath: { \"id\": 120 },\n\tparameters: { arg1: \"hello\", arg2: \"world\" },\n\theaders: { \"test-header\": \"client-api\" },\n\tdata: \"<xml><arg1>hello</arg1><arg2>world</arg2></xml>\",\n\trequestConfig: {\n\t\ttimeout: 1000, //request timeout in milliseconds\n\t\tnoDelay: true, //Enable/disable the Nagle algorithm\n\t\tkeepAlive: true, //Enable/disable keep-alive functionalityidle socket.\n\t\tkeepAliveDelay: 1000 //and optionally set the initial delay before the first keepalive probe is sent\n\t},\n\tresponseConfig: {\n\t\ttimeout: 1000 //response timeout\n\t}\n};\n\n\nvar req = client.post(\"http://remote.site/rest/xml/${id}/method?arg1=hello&arg2=world\", args, function (data, response) {\n\t// parsed response body as js object\n\tconsole.log(data);\n\t// raw response\n\tconsole.log(response);\n});\n\nreq.on('requestTimeout', function (req) {\n\tconsole.log('request has expired');\n\treq.abort();\n});\n\nreq.on('responseTimeout', function (res) {\n\tconsole.log('response has expired');\n\n});\n\n//it's usefull to handle request errors to avoid, for example, socket hang up errors on request timeouts\nreq.on('error', function (err) {\n\tconsole.log('request error', err);\n});\n```\n\n\n### Connect through proxy\n\nJust pass proxy configuration as option to client.\n\n\n```javascript\nvar Client = require('node-rest-client').Client;\n\n// configure proxy\nvar options_proxy = {\n\tproxy: {\n\t\thost: \"proxy.foo.com\",\n\t\tport: 8080,\n\t\tuser: \"proxyuser\",\n\t\tpassword: \"123\",\n\t\ttunnel: true\n\t}\n};\n\nvar client = new Client(options_proxy);\n```\n\nclient has 2 ways to connect to target site through a proxy server: tunnel or direct request, the first one is the default option\nso if you want to use direct request you must set tunnel off.\n\n```javascript\nvar Client = require('node-rest-client').Client;\n\n// configure proxy\nvar options_proxy = {\n\tproxy: {\n\t\thost: \"proxy.foo.com\",\n\t\tport: 8080,\n\t\tuser: \"proxyuser\",\n\t\tpassword: \"123\",\n\t\ttunnel: false // use direct request to proxy\n\t}\n};\n\nvar client = new Client(options_proxy);\n```\n\n\n\n### Basic HTTP auth\n\nJust pass username and password or just username, if no password is required by remote site, as option to client. Every request done with the client will pass username and password or just username if no password is required as basic authorization header.\n\n```javascript\nvar Client = require('node-rest-client').Client;\n\n// configure basic http auth for every request\nvar options_auth = { user: \"admin\", password: \"123\" };\n\nvar client = new Client(options_auth);\n```\n\n### Options parameters\n\nYou can pass the following args when creating a new client:\n\n```javascript\nvar options = {\n\t// proxy configuration\n\tproxy: {\n\t\thost: \"proxy.foo.com\", // proxy host\n\t\tport: 8080, // proxy port\n\t\tuser: \"ellen\", // proxy username if required\n\t\tpassword: \"ripley\" // proxy pass if required\n\t},\n\t// aditional connection options passed to node http.request y https.request methods \n\t// (ie: options to connect to IIS with SSL)\t\n\tconnection: {\n\t\tsecureOptions: constants.SSL_OP_NO_TLSv1_2,\n\t\tciphers: 'ECDHE-RSA-AES256-SHA:AES256-SHA:RC4-SHA:RC4:HIGH:!MD5:!aNULL:!EDH:!AESGCM',\n\t\thonorCipherOrder: true\n\t},\n\t// customize mime types for json or xml connections\n\tmimetypes: {\n\t\tjson: [\"application/json\", \"application/json;charset=utf-8\"],\n\t\txml: [\"application/xml\", \"application/xml;charset=utf-8\"]\n\t},\n\tuser: \"admin\", // basic http auth username if required\n\tpassword: \"123\", // basic http auth password if required\n\trequestConfig: {\n\t\ttimeout: 1000, //request timeout in milliseconds\n\t\tnoDelay: true, //Enable/disable the Nagle algorithm\n\t\tkeepAlive: true, //Enable/disable keep-alive functionalityidle socket.\n\t\tkeepAliveDelay: 1000 //and optionally set the initial delay before the first keepalive probe is sent\n\t},\n\tresponseConfig: {\n\t\ttimeout: 1000 //response timeout\n\t}\n};\n```\nNote that requestConfig and responseConfig options if set on client instantiation apply to all of its requests/responses\nand is only overriden by request or reponse configs passed as args in method calls.\n\n\n### Managing Requests\n\nEach REST method invocation returns a request object with specific request options and error, requestTimeout and responseTimeout event handlers.\n\n```javascript\nvar Client = require('node-rest-client').Client;\n\nvar client = new Client();\n\nvar args = {\n\trequesConfig: { timeout: 1000 },\n\tresponseConfig: { timeout: 2000 }\n};\n\n// direct way\nvar req1 = client.get(\"http://remote.site/rest/xml/method\", args, function (data, response) {\n\t// parsed response body as js object\n\tconsole.log(data);\n\t// raw response\n\tconsole.log(response);\n});\n\n// view req1 options\t\t\nconsole.log(req1.options);\n\n\nreq1.on('requestTimeout', function (req) {\n\tconsole.log(\"request has expired\");\n\treq.abort();\n});\n\nreq1.on('responseTimeout', function (res) {\n\tconsole.log(\"response has expired\");\n\n});\n\n\n// registering remote methods\nclient.registerMethod(\"jsonMethod\", \"http://remote.site/rest/json/method\", \"GET\");\n\nvar req2 = client.methods.jsonMethod(function (data, response) {\n\t// parsed response body as js object\n\tconsole.log(data);\n\t// raw response\n\tconsole.log(response);\n});\n\n// handling specific req2 errors\nreq2.on('error', function (err) {\n\tconsole.log('something went wrong on req2!!', err.request.options);\n});\n```\n\n###  Error Handling\n\n Now you can handle error events in two places: on client or on each request.\n\n```javascript\nvar client = new Client(options_auth);\n\n// handling request error events\nclient.get(\"http://remote.site/rest/xml/method\", function (data, response) {\n\t// parsed response body as js object\n\tconsole.log(data);\n\t// raw response\n\tconsole.log(response);\n}).on('error', function (err) {\n\tconsole.log('something went wrong on the request', err.request.options);\n});\n\n// handling client error events\nclient.on('error', function (err) {\n\tconsole.error('Something went wrong on the client', err);\n});\n```\n",
  "readmeFilename": "readme.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/aacerox/node-rest-client.git"
  },
  "version": "1.8.0"
}
